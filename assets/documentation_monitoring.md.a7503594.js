import{_ as e,c as t,o as i,d as o}from"./app.7e97e3a5.js";const p=JSON.parse('{"title":"Monitoring","description":"","frontmatter":{},"headers":[],"relativePath":"documentation/monitoring.md"}'),n={name:"documentation/monitoring.md"},a=o('<h1 id="monitoring" tabindex="-1">Monitoring <a class="header-anchor" href="#monitoring" aria-hidden="true">#</a></h1><blockquote><p><strong>Formal Definition</strong>: Monitoring is an automation strategy for inferring and presenting service states given a collection of service variables. <br></p></blockquote><p>It\u2019s therefore an automation strategy with the following end goals.</p><ul><li>Infer service states</li><li>Present service states</li></ul><p>We use the term \u201Cautomation strategy\u201D here because the goals identified must all be achieved through software automation. In contrast, manually inferring service states such as running complex system commands would require a service modifier to determine combinations of these system commands, parse their output into something consumable, then finally interpret this output into a service state. Service monitoring and observability automate all these manual methods so that their service modifiers can focus more on their core intents and ultimately gain value from them. Using the cloud storage service example, a service modifier such as an engineer would need to know the following service states happened in order to know that there were no errors during the file upload;</p><ul><li>UploadInProgress</li><li>U\u0336p\u0336l\u0336o\u0336a\u0336d\u0336F\u0336a\u0336i\u0336l\u0336e\u0336d\u0336</li><li>UploadFinished</li></ul><p>If the goals above aren\u2019t guaranteed, then it\u2019s likely that automation is not a central purpose of monitoring or observability implementation. In this case, any service modifier can be subjective about the values that it brings.</p>',7),r=[a];function s(l,c,m,d,u,h){return i(),t("div",null,r)}const f=e(n,[["render",s]]);export{p as __pageData,f as default};
